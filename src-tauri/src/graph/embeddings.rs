use serde::{Deserialize, Serialize};
use reqwest::Client;
use tauri::AppHandle;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Embedding {
    pub vector: Vec<f32>,
    pub model: String,
}

#[derive(Debug, Clone)]
pub struct EmbeddingGenerator {
    client: Client,
    app_handle: AppHandle,
}

impl EmbeddingGenerator {
    pub fn new(app_handle: AppHandle) -> Self {
        Self {
            client: Client::new(),
            app_handle,
        }
    }
    
    pub async fn new_if_configured() -> Result<Self, String> {
        // This is a placeholder - in real implementation, get app handle from context
        Err("Embeddings not configured".to_string())
    }
    
    pub async fn generate_embedding(&self, text: &str) -> Result<Vec<f32>, String> {
        // Embeddings should be generated by the Neo4j MCP server
        // which now has local embedding support via @xenova/transformers
        // For now, we'll skip embedding generation during graph sync
        // The Neo4j MCP server can be used to generate embeddings on-demand
        Err("Embedding generation skipped - use Neo4j MCP server for embeddings".to_string())
    }
    
    pub async fn generate_embeddings_batch(&self, texts: Vec<&str>) -> Result<Vec<Embedding>, String> {
        // Embeddings should be generated by the Neo4j MCP server
        // which has local embedding support via @xenova/transformers
        Err("Embeddings should be generated by Neo4j MCP server".to_string())
    }
}

// Helper function to chunk text for embedding
pub fn prepare_text_for_embedding(content: &str, max_tokens: usize) -> Vec<String> {
    // Simple chunking strategy - can be improved with better tokenization
    let words: Vec<&str> = content.split_whitespace().collect();
    let mut chunks = Vec::new();
    let mut current_chunk = String::new();
    let mut word_count = 0;
    
    for word in words {
        if word_count > 0 && word_count + word.len() > max_tokens {
            chunks.push(current_chunk.trim().to_string());
            current_chunk = String::new();
            word_count = 0;
        }
        
        current_chunk.push_str(word);
        current_chunk.push(' ');
        word_count += word.len() + 1;
    }
    
    if !current_chunk.is_empty() {
        chunks.push(current_chunk.trim().to_string());
    }
    
    chunks
}