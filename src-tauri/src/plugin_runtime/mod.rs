// Plugin Runtime Module - Core functionality for sandboxed plugin execution
// This module provides secure, isolated execution environments for third-party plugins

pub mod sandbox;
pub mod ipc;
pub mod permissions;
pub mod permission_commands;
pub mod resources;
pub mod lifecycle;
pub mod apis;
pub mod cli;
pub mod dev_server;
pub mod validator;
pub mod test_framework;
pub mod typescript;
pub mod commands;
pub mod ipc_commands;

use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;
use tauri::AppHandle;

/// Represents a loaded plugin instance
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Plugin {
    pub id: String,
    pub name: String,
    pub version: String,
    pub manifest_path: String,
    pub entry_point: String,
    pub permissions: Vec<String>,
    pub status: PluginStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum PluginStatus {
    Installed,
    Active,
    Inactive,
    Failed,
    Disabled,
}

/// Main plugin runtime manager
pub struct PluginRuntime {
    plugins: Arc<RwLock<HashMap<String, Plugin>>>,
    sandbox_manager: sandbox::SandboxManager,
    ipc_bridge: ipc::IpcBridge,
    permission_manager: permissions::PermissionManager,
    resource_monitor: resources::ResourceMonitor,
    lifecycle_manager: lifecycle::LifecycleManager,
    app_handle: Option<AppHandle>,
}

impl PluginRuntime {
    pub fn new() -> Self {
        Self {
            plugins: Arc::new(RwLock::new(HashMap::new())),
            sandbox_manager: sandbox::SandboxManager::new(),
            ipc_bridge: ipc::IpcBridge::new(),
            permission_manager: permissions::PermissionManager::new(),
            resource_monitor: resources::ResourceMonitor::new(),
            lifecycle_manager: lifecycle::LifecycleManager::new(),
            app_handle: None,
        }
    }

    /// Create a new plugin runtime with a Tauri app handle for WebView creation
    pub fn new_with_handle(app_handle: AppHandle) -> Self {
        let mut sandbox_manager = sandbox::SandboxManager::new();
        sandbox_manager.set_app_handle(app_handle.clone());
        
        Self {
            plugins: Arc::new(RwLock::new(HashMap::new())),
            sandbox_manager,
            ipc_bridge: ipc::IpcBridge::new(),
            permission_manager: permissions::PermissionManager::new(),
            resource_monitor: resources::ResourceMonitor::new(),
            lifecycle_manager: lifecycle::LifecycleManager::new(),
            app_handle: Some(app_handle),
        }
    }

    /// Load a plugin from its manifest path
    pub async fn load_plugin(&self, manifest_path: &str) -> Result<String, PluginError> {
        // Validate manifest
        let manifest = self.lifecycle_manager.validate_manifest(manifest_path).await
            .map_err(|e| PluginError::LifecycleError(e.to_string()))?;
        
        // Generate unique plugin ID
        let plugin_id = Uuid::new_v4().to_string();
        
        // Create plugin instance
        let plugin = Plugin {
            id: plugin_id.clone(),
            name: manifest.name,
            version: manifest.version,
            manifest_path: manifest_path.to_string(),
            entry_point: manifest.entry_point,
            permissions: manifest.permissions,
            status: PluginStatus::Installed,
        };
        
        // Store plugin
        let mut plugins = self.plugins.write().await;
        plugins.insert(plugin_id.clone(), plugin.clone());
        
        // Record telemetry
        self.resource_monitor.record_telemetry(&plugin_id, resources::TelemetryEvent::PluginLoaded {
            plugin_id: plugin_id.clone(),
            name: plugin.name,
            version: plugin.version,
        }).await;
        
        Ok(plugin_id)
    }

    /// Activate a loaded plugin
    pub async fn activate_plugin(&self, plugin_id: &str) -> Result<(), PluginError> {
        let plugins = self.plugins.read().await;
        let plugin = plugins.get(plugin_id)
            .ok_or(PluginError::PluginNotFound)?;
        
        // Check permissions
        self.permission_manager.check_permissions(&plugin.permissions).await
            .map_err(|e| PluginError::PermissionDenied(e.to_string()))?;
        
        // Create sandbox
        let sandbox = self.sandbox_manager.create_sandbox(plugin_id).await
            .map_err(|e| PluginError::SandboxError(e.to_string()))?;
        
        // Setup IPC channel
        self.ipc_bridge.create_channel(plugin_id).await
            .map_err(|e| PluginError::IpcError(e.to_string()))?;
        
        // Load plugin in sandbox and get WebView PID
        let webview_pid = {
            let mut sandbox_guard = sandbox.write().await;
            sandbox_guard.load_plugin(&plugin.entry_point).await
                .map_err(|e| PluginError::SandboxError(e.to_string()))?
        };
        
        // Start resource monitoring with the WebView PID if available
        self.resource_monitor.start_monitoring(plugin_id, webview_pid).await
            .map_err(|e| PluginError::ResourceLimitExceeded(e.to_string()))?;
        
        // If we didn't get a PID directly, try to discover WebView processes
        if webview_pid.is_none() {
            // Use the system monitor's discovery mechanism
            tokio::spawn({
                let monitor = self.resource_monitor.clone();
                let plugin_id = plugin_id.to_string();
                async move {
                    // Give the WebView a moment to start
                    tokio::time::sleep(tokio::time::Duration::from_millis(500)).await;
                    
                    // Try to discover and register WebView processes
                    if let Ok(pids) = monitor.discover_webview_processes().await {
                        if let Some(pid) = pids.first() {
                            monitor.register_webview_process(&plugin_id, *pid as u32).await;
                        }
                    }
                }
            });
        }
        
        // Start periodic resource monitoring
        tokio::spawn({
            let monitor = self.resource_monitor.clone();
            let plugin_id = plugin_id.to_string();
            async move {
                let mut interval = tokio::time::interval(tokio::time::Duration::from_secs(1));
                loop {
                    interval.tick().await;
                    
                    // Check if still monitoring
                    if !monitor.is_monitoring(&plugin_id).await {
                        break;
                    }
                    
                    // Update resource usage and enforce limits
                    if let Err(e) = monitor.update_usage(&plugin_id).await {
                        match e {
                            crate::plugin_runtime::resources::ResourceError::PluginTerminated => {
                                // Plugin was terminated due to resource violation
                                break;
                            },
                            _ => {
                                // Log other errors but continue monitoring
                                eprintln!("Resource monitoring error for {}: {:?}", plugin_id, e);
                            }
                        }
                    }
                }
            }
        });
        
        // Update status
        drop(plugins);
        let mut plugins = self.plugins.write().await;
        if let Some(plugin) = plugins.get_mut(plugin_id) {
            plugin.status = PluginStatus::Active;
        }
        
        // Record telemetry
        self.resource_monitor.record_telemetry(plugin_id, resources::TelemetryEvent::PluginActivated {
            plugin_id: plugin_id.to_string(),
        }).await;
        
        Ok(())
    }

    /// Deactivate a plugin
    pub async fn deactivate_plugin(&self, plugin_id: &str) -> Result<(), PluginError> {
        // Record telemetry
        self.resource_monitor.record_telemetry(plugin_id, resources::TelemetryEvent::PluginDeactivated {
            plugin_id: plugin_id.to_string(),
            reason: "User requested".to_string(),
        }).await;
        
        // Stop resource monitoring
        self.resource_monitor.stop_monitoring(plugin_id).await
            .map_err(|e| PluginError::ResourceLimitExceeded(e.to_string()))?;
        
        // Close IPC channel
        self.ipc_bridge.close_channel(plugin_id).await
            .map_err(|e| PluginError::IpcError(e.to_string()))?;
        
        // Destroy sandbox
        self.sandbox_manager.destroy_sandbox(plugin_id).await
            .map_err(|e| PluginError::SandboxError(e.to_string()))?;
        
        // Update status
        let mut plugins = self.plugins.write().await;
        if let Some(plugin) = plugins.get_mut(plugin_id) {
            plugin.status = PluginStatus::Inactive;
        }
        
        Ok(())
    }

    /// Get all loaded plugins
    pub async fn list_plugins(&self) -> Vec<Plugin> {
        let plugins = self.plugins.read().await;
        plugins.values().cloned().collect()
    }
}

#[derive(Debug, thiserror::Error)]
pub enum PluginError {
    #[error("Plugin not found")]
    PluginNotFound,
    
    #[error("Invalid manifest: {0}")]
    InvalidManifest(String),
    
    #[error("Permission denied: {0}")]
    PermissionDenied(String),
    
    #[error("Sandbox error: {0}")]
    SandboxError(String),
    
    #[error("IPC error: {0}")]
    IpcError(String),
    
    #[error("Resource limit exceeded: {0}")]
    ResourceLimitExceeded(String),
    
    #[error("Lifecycle error: {0}")]
    LifecycleError(String),
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_plugin_runtime_creation_without_app_handle() {
        let runtime = PluginRuntime::new();
        let plugins = runtime.list_plugins().await;
        assert_eq!(plugins.len(), 0);
        
        // Verify no app handle is set
        assert!(!runtime.sandbox_manager.has_app_handle());
    }

    #[tokio::test]
    async fn test_plugin_runtime_with_app_handle() {
        // We can't create a real AppHandle in tests without the test feature
        // But we can verify the structure is correct
        let runtime = PluginRuntime::new();
        
        // The new_with_handle method should exist and compile
        // Real integration testing will need to be done with a running app
        assert!(!runtime.sandbox_manager.has_app_handle());
    }

    #[tokio::test]
    async fn test_sandbox_manager_without_app_handle() {
        let runtime = PluginRuntime::new();
        
        // Create a sandbox without app handle
        let result = runtime.sandbox_manager.create_sandbox("test_plugin").await;
        assert!(result.is_ok());
        
        // Verify the sandbox doesn't have window creation capability
        let sandbox = result.unwrap();
        let sandbox_guard = sandbox.read().await;
        assert!(!sandbox_guard.can_create_window());
    }

    #[tokio::test]
    async fn test_plugin_loading() {
        let runtime = PluginRuntime::new();
        // This will fail until we implement the lifecycle manager
        let result = runtime.load_plugin("test_manifest.json").await;
        assert!(result.is_err());
    }
}